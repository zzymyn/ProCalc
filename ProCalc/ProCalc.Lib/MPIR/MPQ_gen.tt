<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ output extension=".cs" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#
    var Inits = new []
    {
        new { Sig = "MPZ a", Args = "ref a.S", InitFunc = "mpq_set_z" },
        new { Sig = "long a", Args = "a, 1ul", InitFunc = "mpq_set_si" },
        new { Sig = "long a, ulong b", Args = "a, b", InitFunc = "mpq_set_si" },
        new { Sig = "ulong a", Args = "a, 1ul", InitFunc = "mpq_set_ui" },
        new { Sig = "ulong a, ulong b", Args = "a, b", InitFunc = "mpq_set_ui" },
        new { Sig = "double a", Args = "a", InitFunc = "mpq_set_d" },
    };

    var Convs = new []
    {
        new { Type = "MPZ", Mode = "implicit", },
        new { Type = "int", Mode = "implicit", },
        new { Type = "uint", Mode = "implicit", },
        new { Type = "long", Mode = "implicit", },
        new { Type = "ulong", Mode = "implicit", },
        new { Type = "double", Mode = "explicit", },
    };

    var UOps = new []
    {
        new { Op = "-", Func = "mpq_neg" },
    };

    var BinOps = new []
    {
        new { Op = "+", Func = "mpq_add" },
        new { Op = "-", Func = "mpq_sub" },
        new { Op = "*", Func = "mpq_mul" },
        new { Op = "/", Func = "mpq_div" },
    };

    var Funcs = new []
    {
        new { Name = "Abs", Func = "mpq_abs" },
        new { Name = "Inv", Func = "mpq_inv" },
    };

    var ComparisonOps = new []
    {
        new { Op = "<", },
        new { Op = ">", },
        new { Op = "<=", },
        new { Op = ">=", },
        new { Op = "==", },
        new { Op = "!=", },
    };

#>
using System;

namespace ProCalc.Lib.MPIR
{
    public partial class MPQ
    {
        // Constructors:
<#
        foreach (var op in Inits)
        {
#>
        public MPQ(<#= op.Sig #>)
            : this()
        {
            MPIR.<#= op.InitFunc #>(ref S, <#= op.Args #>);
            MPIR.mpq_canonicalize(ref S);
        }

<#
        }
#>

        // Conversions:
<#
        foreach (var op in Convs)
        {
#>
        public static <#= op.Mode #> operator MPQ(<#= op.Type #> a)
        {
            return new MPQ(a);
        }

<#
        }
#>

        // Unary ops:
<#
        foreach (var op in UOps)
        {
#>
        public static MPQ operator <#= op.Op #>(MPQ a)
        {
            var r = new MPQ();
            MPIR.<#= op.Func #>(ref r.S, ref a.S);
            return r;
        }

<#
        }
#>

        // Binary ops:
<#
        foreach (var op in BinOps)
        {
#>
        public static MPQ operator <#= op.Op #>(MPQ a, MPQ b)
        {
            var r = new MPQ();
            MPIR.<#= op.Func #>(ref r.S, ref a.S, ref b.S);
            return r;
        }

<#
        }
#>

        // Funcs:
<#
        foreach (var op in Funcs)
        {
#>
        public MPQ <#= op.Name #>()
        {
            var r = new MPQ();
            MPIR.<#= op.Func #>(ref r.S, ref S);
            return r;
        }

<#
        }
#>

        // Comparison ops:
<#
        foreach (var op in ComparisonOps)
        {
#>
        public static bool operator <#= op.Op #>(MPQ a, MPQ b)
        {
            return a.CompareTo(b) <#= op.Op #> 0;
        }

<#
        }
#>
    }
}
